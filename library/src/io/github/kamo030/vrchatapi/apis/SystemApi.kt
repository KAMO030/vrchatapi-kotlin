/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.github.kamo030.vrchatapi.apis

import io.github.kamo030.vrchatapi.models.APIConfig
import io.github.kamo030.vrchatapi.models.APIHealth
import io.github.kamo030.vrchatapi.models.Error
import io.github.kamo030.vrchatapi.models.InfoPush

import io.github.kamo030.vrchatapi.infrastructure.*
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

open class SystemApi(
    baseUrl: String = ApiClient.BASE_URL,
    httpClientEngine: HttpClientEngine? = null,
    httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
    jsonSerializer: Json = ApiClient.JSON_DEFAULT
) : ApiClient(baseUrl, httpClientEngine, httpClientConfig, jsonSerializer) {

    /**
     * Download CSS
     * Fetches the CSS code to the frontend React website.
     * @param variant Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management. (optional, default to public)
     * @param branch Specifies which git branch the site should load frontend source code from. (optional, default to "main")
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getCSS(variant: kotlin.String? = public, branch: kotlin.String? = "main"): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        variant?.apply { localVariableQuery["variant"] = listOf("$variant") }
        branch?.apply { localVariableQuery["branch"] = listOf("$branch") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/css/app.css",
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Fetch API Config
     * API config contains configuration that the clients needs to work properly.  Currently the most important value here is &#x60;clientApiKey&#x60; which is used for all other API endpoints.
     * @return APIConfig
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getConfig(): HttpResponse<APIConfig> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/config",
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Current Online Users
     * Returns the current number of online users.  **NOTE:** The response type is not a JSON object, but a simple JSON integer.
     * @return kotlin.Int
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getCurrentOnlineUsers(): HttpResponse<kotlin.Int> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/visits",
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Check API Health
     * ~~Gets the overall health status, the server name, and the current build version tag of the API.~~  **DEPRECATED:** VRChat has suddenly restricted this endpoint for unknown reasons, and now always return 401 Unauthorized.
     * @return APIHealth
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getHealth(): HttpResponse<APIHealth> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/health",
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Show Information Notices
     * IPS (Info Push System) is a system for VRChat to push out dynamic information to the client. This is primarily used by the Quick-Menu info banners, but can also be used to e.g. alert you to update your game to the latest version.  &#x60;include&#x60; is used to query what Information Pushes should be included in the response. If include is missing or empty, then no notices will normally be returned. This is an \&quot;any of\&quot; search.  &#x60;require&#x60; is used to limit what Information Pushes should be included in the response. This is usually used in combination with &#x60;include&#x60;, and is an \&quot;all of\&quot; search.
     * @param require Tags to include (comma-separated). All of the tags needs to be present. (optional)
     * @param include Tags to include (comma-separated). Any of the tags needs to be present. (optional)
     * @return kotlin.collections.List<InfoPush>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getInfoPush(require: kotlin.String? = null, include: kotlin.String? = null): HttpResponse<kotlin.collections.List<InfoPush>> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        require?.apply { localVariableQuery["require"] = listOf("$require") }
        include?.apply { localVariableQuery["include"] = listOf("$include") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/infoPush",
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetInfoPushResponse>().map { value }
    }

    @Serializable
    private class GetInfoPushResponse(val value: List<InfoPush>) {
        @Serializer(GetInfoPushResponse::class)
        companion object : KSerializer<GetInfoPushResponse> {
            private val serializer: KSerializer<List<InfoPush>> = serializer<List<InfoPush>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: GetInfoPushResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = GetInfoPushResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Download JavaScript
     * Fetches the JavaScript code to the frontend React website.
     * @param variant Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management. (optional, default to public)
     * @param branch Specifies which git branch the site should load frontend source code from. (optional, default to "main")
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getJavaScript(variant: kotlin.String? = public, branch: kotlin.String? = "main"): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        variant?.apply { localVariableQuery["variant"] = listOf("$variant") }
        branch?.apply { localVariableQuery["branch"] = listOf("$branch") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/js/app.js",
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Current System Time
     * Returns the current time of the API server.  **NOTE:** The response type is not a JSON object, but a simple JSON string.
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getSystemTime(): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/time",
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


}
