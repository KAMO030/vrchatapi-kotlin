/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.github.kamo030.vrchatapi.apis

import io.github.kamo030.vrchatapi.models.Error
import io.github.kamo030.vrchatapi.models.FriendStatus
import io.github.kamo030.vrchatapi.models.LimitedUser
import io.github.kamo030.vrchatapi.models.Notification
import io.github.kamo030.vrchatapi.models.Success

import io.github.kamo030.vrchatapi.infrastructure.*
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

open class FriendsApi(
    baseUrl: String = ApiClient.BASE_URL,
    httpClientEngine: HttpClientEngine? = null,
    httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
    jsonSerializer: Json = ApiClient.JSON_DEFAULT
) : ApiClient(baseUrl, httpClientEngine, httpClientConfig, jsonSerializer) {

    /**
     * Delete Friend Request
     * Deletes an outgoing pending friend request to another user. To delete an incoming friend request, use the &#x60;deleteNotification&#x60; endpoint instead.
     * @param userId Must be a valid user ID.
     * @return Success
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deleteFriendRequest(userId: kotlin.String): HttpResponse<Success> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/user/{userId}/friendRequest".replace("{" + "userId" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Send Friend Request
     * Send a friend request to another user.
     * @param userId Must be a valid user ID.
     * @return Notification
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun friend(userId: kotlin.String): HttpResponse<Notification> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/user/{userId}/friendRequest".replace("{" + "userId" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Check Friend Status
     * Retrieve if the user is currently a friend with a given user, if they have an outgoing friend request, and if they have an incoming friend request. The proper way to receive and accept friend request is by checking if the user has an incoming &#x60;Notification&#x60; of type &#x60;friendRequest&#x60;, and then accepting that notification.
     * @param userId Must be a valid user ID.
     * @return FriendStatus
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getFriendStatus(userId: kotlin.String): HttpResponse<FriendStatus> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/user/{userId}/friendStatus".replace("{" + "userId" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List Friends
     * List information about friends.
     * @param offset A zero-based offset from the default object sorting from where search results start. (optional)
     * @param n The number of objects to return. (optional, default to 60)
     * @param offline Returns *only* offline users if true, returns only online and active users if false (optional)
     * @return kotlin.collections.List<LimitedUser>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getFriends(offset: kotlin.Int? = null, n: kotlin.Int? = 60, offline: kotlin.Boolean? = null): HttpResponse<kotlin.collections.List<LimitedUser>> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        offset?.apply { localVariableQuery["offset"] = listOf("$offset") }
        n?.apply { localVariableQuery["n"] = listOf("$n") }
        offline?.apply { localVariableQuery["offline"] = listOf("$offline") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/auth/user/friends",
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetFriendsResponse>().map { value }
    }

    @Serializable(GetFriendsResponse.Companion::class)
    private class GetFriendsResponse(val value: List<LimitedUser>) {
        @Serializer(GetFriendsResponse::class)
        companion object : KSerializer<GetFriendsResponse> {
            private val serializer: KSerializer<List<LimitedUser>> = serializer<List<LimitedUser>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: GetFriendsResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = GetFriendsResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Unfriend
     * Unfriend a user by ID.
     * @param userId Must be a valid user ID.
     * @return Success
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun unfriend(userId: kotlin.String): HttpResponse<Success> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/auth/user/friends/{userId}".replace("{" + "userId" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


}
