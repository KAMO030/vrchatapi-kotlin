/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.github.kamo030.vrchatapi.apis

import io.github.kamo030.vrchatapi.models.CreateFileRequest
import io.github.kamo030.vrchatapi.models.CreateFileVersionRequest
import io.github.kamo030.vrchatapi.models.Error
import io.github.kamo030.vrchatapi.models.FileAnalysis
import io.github.kamo030.vrchatapi.models.FileUploadURL
import io.github.kamo030.vrchatapi.models.FileVersionUploadStatus
import io.github.kamo030.vrchatapi.models.FinishFileDataUploadRequest

import io.github.kamo030.vrchatapi.infrastructure.*
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

open class FilesApi(
    baseUrl: String = ApiClient.BASE_URL,
    httpClientEngine: HttpClientEngine? = null,
    httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
    jsonSerializer: Json = ApiClient.JSON_DEFAULT
) : ApiClient(baseUrl, httpClientEngine, httpClientConfig, jsonSerializer) {

    /**
     * Create File
     * Creates a new File object
     * @param createFileRequest  (optional)
     * @return io.github.kamo030.vrchatapi.infrastructure.OctetByteArray
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createFile(createFileRequest: CreateFileRequest? = null): HttpResponse<io.github.kamo030.vrchatapi.infrastructure.OctetByteArray> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = createFileRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/file",
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Create File Version
     * Creates a new FileVersion. Once a Version has been created, proceed to the &#x60;/file/{fileId}/{versionId}/file/start&#x60; endpoint to start a file upload.
     * @param fileId Must be a valid file ID.
     * @param createFileVersionRequest  (optional)
     * @return io.github.kamo030.vrchatapi.infrastructure.OctetByteArray
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createFileVersion(fileId: kotlin.String, createFileVersionRequest: CreateFileVersionRequest? = null): HttpResponse<io.github.kamo030.vrchatapi.infrastructure.OctetByteArray> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = createFileVersionRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/file/{fileId}".replace("{" + "fileId" + "}", "$fileId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Delete File
     * Deletes a File object.
     * @param fileId Must be a valid file ID.
     * @return io.github.kamo030.vrchatapi.infrastructure.OctetByteArray
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deleteFile(fileId: kotlin.String): HttpResponse<io.github.kamo030.vrchatapi.infrastructure.OctetByteArray> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/file/{fileId}".replace("{" + "fileId" + "}", "$fileId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Delete File Version
     * Delete a specific version of a file. You can only delete the latest version.
     * @param fileId Must be a valid file ID.
     * @param versionId Version ID of the asset.
     * @return io.github.kamo030.vrchatapi.infrastructure.OctetByteArray
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deleteFileVersion(fileId: kotlin.String, versionId: kotlin.Int): HttpResponse<io.github.kamo030.vrchatapi.infrastructure.OctetByteArray> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/file/{fileId}/{versionId}".replace("{" + "fileId" + "}", "$fileId").replace("{" + "versionId" + "}", "$versionId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Download File Version
     * Downloads the file with the provided version number.  **Version Note:** Version 0 is always when the file was created. The real data is usually always located in version 1 and up.  **Extension Note:** Files are not guaranteed to have a file extensions. UnityPackage files tends to have it, images through this endpoint do not. You are responsible for appending file extension from the &#x60;extension&#x60; field when neccesary.
     * @param fileId Must be a valid file ID.
     * @param versionId Version ID of the asset.
     * @return void
     */
    open suspend fun downloadFileVersion(fileId: kotlin.String, versionId: kotlin.Int): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/file/{fileId}/{versionId}".replace("{" + "fileId" + "}", "$fileId").replace("{" + "versionId" + "}", "$versionId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Finish FileData Upload
     * Finish an upload of a FileData. This will mark it as \&quot;complete\&quot;. After uploading the &#x60;file&#x60; for Avatars and Worlds you then have to upload a &#x60;signature&#x60; file.
     * @param fileId Must be a valid file ID.
     * @param versionId Version ID of the asset.
     * @param fileType Type of file.
     * @param finishFileDataUploadRequest Please see documentation on ETag&#39;s: [https://teppen.io/2018/06/23/aws_s3_etags/](https://teppen.io/2018/06/23/aws_s3_etags/)  ETag&#39;s should NOT be present when uploading a &#x60;signature&#x60;. (optional)
     * @return io.github.kamo030.vrchatapi.infrastructure.OctetByteArray
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun finishFileDataUpload(fileId: kotlin.String, versionId: kotlin.Int, fileType: kotlin.String, finishFileDataUploadRequest: FinishFileDataUploadRequest? = null): HttpResponse<io.github.kamo030.vrchatapi.infrastructure.OctetByteArray> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = finishFileDataUploadRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/file/{fileId}/{versionId}/{fileType}/finish".replace("{" + "fileId" + "}", "$fileId").replace("{" + "versionId" + "}", "$versionId").replace("{" + "fileType" + "}", "$fileType"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Show File
     * Shows general information about the \&quot;File\&quot; object. Each File can have several \&quot;Version\&quot;&#39;s, and each Version can have multiple real files or \&quot;Data\&quot; blobs.
     * @param fileId Must be a valid file ID.
     * @return io.github.kamo030.vrchatapi.infrastructure.OctetByteArray
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getFile(fileId: kotlin.String): HttpResponse<io.github.kamo030.vrchatapi.infrastructure.OctetByteArray> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/file/{fileId}".replace("{" + "fileId" + "}", "$fileId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get File Version Analysis
     * Get the performance analysis for the uploaded assets of an avatar
     * @param fileId Must be a valid file ID.
     * @param versionId Version ID of the asset.
     * @return FileAnalysis
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getFileAnalysis(fileId: kotlin.String, versionId: kotlin.Int): HttpResponse<FileAnalysis> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/analysis/{fileId}/{versionId}".replace("{" + "fileId" + "}", "$fileId").replace("{" + "versionId" + "}", "$versionId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get File Version Analysis Security
     * Get the security performance analysis for the uploaded assets of an avatar
     * @param fileId Must be a valid file ID.
     * @param versionId Version ID of the asset.
     * @return FileAnalysis
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getFileAnalysisSecurity(fileId: kotlin.String, versionId: kotlin.Int): HttpResponse<FileAnalysis> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/analysis/{fileId}/{versionId}/security".replace("{" + "fileId" + "}", "$fileId").replace("{" + "versionId" + "}", "$versionId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get File Version Analysis Standard
     * Get the standard performance analysis for the uploaded assets of an avatar
     * @param fileId Must be a valid file ID.
     * @param versionId Version ID of the asset.
     * @return FileAnalysis
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getFileAnalysisStandard(fileId: kotlin.String, versionId: kotlin.Int): HttpResponse<FileAnalysis> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/analysis/{fileId}/{versionId}/standard".replace("{" + "fileId" + "}", "$fileId").replace("{" + "versionId" + "}", "$versionId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Check FileData Upload Status
     * Retrieves the upload status for file upload. Can currently only be accessed when &#x60;status&#x60; is &#x60;waiting&#x60;. Trying to access it on a file version already uploaded currently times out.
     * @param fileId Must be a valid file ID.
     * @param versionId Version ID of the asset.
     * @param fileType Type of file.
     * @return FileVersionUploadStatus
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getFileDataUploadStatus(fileId: kotlin.String, versionId: kotlin.Int, fileType: kotlin.String): HttpResponse<FileVersionUploadStatus> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/file/{fileId}/{versionId}/{fileType}/status".replace("{" + "fileId" + "}", "$fileId").replace("{" + "versionId" + "}", "$versionId").replace("{" + "fileType" + "}", "$fileType"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List Files
     * Returns a list of files
     * @param tag Tag, for example \&quot;icon\&quot; or \&quot;gallery\&quot;, not included by default. (optional)
     * @param userId UserID, will always generate a 500 permission error. (optional)
     * @param n The number of objects to return. (optional, default to 60)
     * @param offset A zero-based offset from the default object sorting from where search results start. (optional)
     * @return kotlin.collections.List<io.github.kamo030.vrchatapi.infrastructure.OctetByteArray>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getFiles(tag: kotlin.String? = null, userId: kotlin.String? = null, n: kotlin.Int? = 60, offset: kotlin.Int? = null): HttpResponse<kotlin.collections.List<io.github.kamo030.vrchatapi.infrastructure.OctetByteArray>> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        tag?.apply { localVariableQuery["tag"] = listOf("$tag") }
        userId?.apply { localVariableQuery["userId"] = listOf("$userId") }
        n?.apply { localVariableQuery["n"] = listOf("$n") }
        offset?.apply { localVariableQuery["offset"] = listOf("$offset") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/files",
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetFilesResponse>().map { value }
    }

    @Serializable(GetFilesResponse.Companion::class)
    data class GetFilesResponse(val value: List<io.github.kamo030.vrchatapi.infrastructure.OctetByteArray>) {
        companion object : KSerializer<GetFilesResponse> {
            private val serializer: KSerializer<List<io.github.kamo030.vrchatapi.infrastructure.OctetByteArray>> = serializer<List<io.github.kamo030.vrchatapi.infrastructure.OctetByteArray>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: GetFilesResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = GetFilesResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Start FileData Upload
     * Starts an upload of a specific FilePart. This endpoint will return an AWS URL which you can PUT data to. You need to call this and receive a new AWS API URL for each &#x60;partNumber&#x60;. Please see AWS&#39;s REST documentation on \&quot;PUT Object to S3\&quot; on how to upload. Once all parts has been uploaded, proceed to &#x60;/finish&#x60; endpoint.  **Note:** &#x60;nextPartNumber&#x60; seems like it is always ignored. Despite it returning 0, first partNumber is always 1.
     * @param fileId Must be a valid file ID.
     * @param versionId Version ID of the asset.
     * @param fileType Type of file.
     * @param partNumber The part number to start uploading. If not provided, the first part will be started. (optional)
     * @return FileUploadURL
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun startFileDataUpload(fileId: kotlin.String, versionId: kotlin.Int, fileType: kotlin.String, partNumber: kotlin.Int? = null): HttpResponse<FileUploadURL> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        partNumber?.apply { localVariableQuery["partNumber"] = listOf("$partNumber") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/file/{fileId}/{versionId}/{fileType}/start".replace("{" + "fileId" + "}", "$fileId").replace("{" + "versionId" + "}", "$versionId").replace("{" + "fileType" + "}", "$fileType"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


}
