/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.github.kamo030.vrchatapi.apis

import io.github.kamo030.vrchatapi.models.Error
import io.github.kamo030.vrchatapi.models.Notification
import io.github.kamo030.vrchatapi.models.Success

import io.github.kamo030.vrchatapi.infrastructure.*
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

open class NotificationsApi(
    baseUrl: String = ApiClient.BASE_URL,
    httpClientEngine: HttpClientEngine? = null,
    httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
    jsonSerializer: Json = ApiClient.JSON_DEFAULT
) : ApiClient(baseUrl, httpClientEngine, httpClientConfig, jsonSerializer) {

    /**
     * Accept Friend Request
     * Accept a friend request by notification &#x60;frq_&#x60; ID. Friend requests can be found using the NotificationsAPI &#x60;getNotifications&#x60; by filtering of type &#x60;friendRequest&#x60;.
     * @param notificationId Must be a valid notification ID.
     * @return Success
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun acceptFriendRequest(notificationId: kotlin.String): HttpResponse<Success> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/auth/user/notifications/{notificationId}/accept".replace("{" + "notificationId" + "}", "$notificationId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Clear All Notifications
     * Clear **all** notifications.
     * @return Success
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun clearNotifications(): HttpResponse<Success> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/auth/user/notifications/clear",
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Delete Notification
     * Delete a notification.
     * @param notificationId Must be a valid notification ID.
     * @return Notification
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deleteNotification(notificationId: kotlin.String): HttpResponse<Notification> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/auth/user/notifications/{notificationId}/hide".replace("{" + "notificationId" + "}", "$notificationId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Show notification
     * Get a notification by notification &#x60;not_&#x60; ID.
     * @param notificationId Must be a valid notification ID.
     * @return Notification
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getNotification(notificationId: kotlin.String): HttpResponse<Notification> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/auth/user/notifications/{notificationId}".replace("{" + "notificationId" + "}", "$notificationId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List Notifications
     * Retrieve all of the current user&#39;s notifications.
     * @param type Only send notifications of this type (can use &#x60;all&#x60; for all). This parameter no longer does anything, and is deprecated. (optional)
     * @param sent Return notifications sent by the user. Must be false or omitted. (optional)
     * @param hidden Whether to return hidden or non-hidden notifications. True only allowed on type &#x60;friendRequest&#x60;. (optional)
     * @param after Only return notifications sent after this Date. Ignored if type is &#x60;friendRequest&#x60;. (optional)
     * @param n The number of objects to return. (optional, default to 60)
     * @param offset A zero-based offset from the default object sorting from where search results start. (optional)
     * @return kotlin.collections.List<Notification>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getNotifications(type: kotlin.String? = null, sent: kotlin.Boolean? = null, hidden: kotlin.Boolean? = null, after: kotlin.String? = null, n: kotlin.Int? = 60, offset: kotlin.Int? = null): HttpResponse<kotlin.collections.List<Notification>> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        type?.apply { localVariableQuery["type"] = listOf("$type") }
        sent?.apply { localVariableQuery["sent"] = listOf("$sent") }
        hidden?.apply { localVariableQuery["hidden"] = listOf("$hidden") }
        after?.apply { localVariableQuery["after"] = listOf("$after") }
        n?.apply { localVariableQuery["n"] = listOf("$n") }
        offset?.apply { localVariableQuery["offset"] = listOf("$offset") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/auth/user/notifications",
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetNotificationsResponse>().map { value }
    }

    @Serializable
    private class GetNotificationsResponse(val value: List<Notification>) {
        @Serializer(GetNotificationsResponse::class)
        companion object : KSerializer<GetNotificationsResponse> {
            private val serializer: KSerializer<List<Notification>> = serializer<List<Notification>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: GetNotificationsResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = GetNotificationsResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Mark Notification As Read
     * Mark a notification as seen.
     * @param notificationId Must be a valid notification ID.
     * @return Notification
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun markNotificationAsRead(notificationId: kotlin.String): HttpResponse<Notification> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/auth/user/notifications/{notificationId}/see".replace("{" + "notificationId" + "}", "$notificationId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


}
