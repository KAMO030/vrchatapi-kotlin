/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.github.kamo030.vrchatapi.apis

import io.github.kamo030.vrchatapi.models.AddFavoriteRequest
import io.github.kamo030.vrchatapi.models.Error
import io.github.kamo030.vrchatapi.models.Favorite
import io.github.kamo030.vrchatapi.models.FavoriteGroup
import io.github.kamo030.vrchatapi.models.FavoriteLimits
import io.github.kamo030.vrchatapi.models.Success
import io.github.kamo030.vrchatapi.models.UpdateFavoriteGroupRequest

import io.github.kamo030.vrchatapi.infrastructure.*
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

open class FavoritesApi(
    baseUrl: String = ApiClient.BASE_URL,
    httpClientEngine: HttpClientEngine? = null,
    httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
    jsonSerializer: Json = ApiClient.JSON_DEFAULT
) : ApiClient(baseUrl, httpClientEngine, httpClientConfig, jsonSerializer) {

    /**
     * Add Favorite
     * Add a new favorite.  Friend groups are named &#x60;group_0&#x60; through &#x60;group_3&#x60;. Avatar and World groups are named &#x60;avatars1&#x60; to &#x60;avatars4&#x60; and &#x60;worlds1&#x60; to &#x60;worlds4&#x60;.  You cannot add people whom you are not friends with to your friends list. Destroying a friendship removes the person as favorite on both sides.
     * @param addFavoriteRequest  (optional)
     * @return Favorite
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun addFavorite(addFavoriteRequest: AddFavoriteRequest? = null): HttpResponse<Favorite> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = addFavoriteRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/favorites",
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Clear Favorite Group
     * Clear ALL contents of a specific favorite group.
     * @param favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
     * @param favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
     * @param userId Must be a valid user ID.
     * @return Success
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun clearFavoriteGroup(favoriteGroupType: kotlin.String, favoriteGroupName: kotlin.String, userId: kotlin.String): HttpResponse<Success> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/favorite/group/{favoriteGroupType}/{favoriteGroupName}/{userId}".replace("{" + "favoriteGroupType" + "}", "$favoriteGroupType").replace("{" + "favoriteGroupName" + "}", "$favoriteGroupName").replace("{" + "userId" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Show Favorite
     * Return information about a specific Favorite.
     * @param favoriteId Must be a valid favorite ID.
     * @return Favorite
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getFavorite(favoriteId: kotlin.String): HttpResponse<Favorite> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/favorites/{favoriteId}".replace("{" + "favoriteId" + "}", "$favoriteId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Show Favorite Group
     * Fetch information about a specific favorite group.
     * @param favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
     * @param favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
     * @param userId Must be a valid user ID.
     * @return FavoriteGroup
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getFavoriteGroup(favoriteGroupType: kotlin.String, favoriteGroupName: kotlin.String, userId: kotlin.String): HttpResponse<FavoriteGroup> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/favorite/group/{favoriteGroupType}/{favoriteGroupName}/{userId}".replace("{" + "favoriteGroupType" + "}", "$favoriteGroupType").replace("{" + "favoriteGroupName" + "}", "$favoriteGroupName").replace("{" + "userId" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List Favorite Groups
     * Return a list of favorite groups owned by a user. Returns the same information as &#x60;getFavoriteGroups&#x60;.
     * @param n The number of objects to return. (optional, default to 60)
     * @param offset A zero-based offset from the default object sorting from where search results start. (optional)
     * @param ownerId The owner of whoms favorite groups to return. Must be a UserID. (optional)
     * @return kotlin.collections.List<FavoriteGroup>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getFavoriteGroups(n: kotlin.Int? = 60, offset: kotlin.Int? = null, ownerId: kotlin.String? = null): HttpResponse<kotlin.collections.List<FavoriteGroup>> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        n?.apply { localVariableQuery["n"] = listOf("$n") }
        offset?.apply { localVariableQuery["offset"] = listOf("$offset") }
        ownerId?.apply { localVariableQuery["ownerId"] = listOf("$ownerId") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/favorite/groups",
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetFavoriteGroupsResponse>().map { value }
    }

    @Serializable(GetFavoriteGroupsResponse.Companion::class)
    private class GetFavoriteGroupsResponse(val value: List<FavoriteGroup>) {
        @Serializer(GetFavoriteGroupsResponse::class)
        companion object : KSerializer<GetFavoriteGroupsResponse> {
            private val serializer: KSerializer<List<FavoriteGroup>> = serializer<List<FavoriteGroup>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: GetFavoriteGroupsResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = GetFavoriteGroupsResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Get Favorite Limits
     * Return information about a specific Favorite.
     * @return FavoriteLimits
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getFavoriteLimits(): HttpResponse<FavoriteLimits> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/auth/user/favoritelimits",
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List Favorites
     * Returns a list of favorites.
     * @param n The number of objects to return. (optional, default to 60)
     * @param offset A zero-based offset from the default object sorting from where search results start. (optional)
     * @param type The type of favorites to return, FavoriteType. (optional)
     * @param tag Tags to include (comma-separated). Any of the tags needs to be present. (optional)
     * @return kotlin.collections.List<Favorite>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getFavorites(n: kotlin.Int? = 60, offset: kotlin.Int? = null, type: kotlin.String? = null, tag: kotlin.String? = null): HttpResponse<kotlin.collections.List<Favorite>> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        n?.apply { localVariableQuery["n"] = listOf("$n") }
        offset?.apply { localVariableQuery["offset"] = listOf("$offset") }
        type?.apply { localVariableQuery["type"] = listOf("$type") }
        tag?.apply { localVariableQuery["tag"] = listOf("$tag") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/favorites",
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetFavoritesResponse>().map { value }
    }

    @Serializable(GetFavoritesResponse.Companion::class)
    private class GetFavoritesResponse(val value: List<Favorite>) {
        @Serializer(GetFavoritesResponse::class)
        companion object : KSerializer<GetFavoritesResponse> {
            private val serializer: KSerializer<List<Favorite>> = serializer<List<Favorite>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: GetFavoritesResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = GetFavoritesResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Remove Favorite
     * Remove a favorite from your favorites list.
     * @param favoriteId Must be a valid favorite ID.
     * @return Success
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun removeFavorite(favoriteId: kotlin.String): HttpResponse<Success> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/favorites/{favoriteId}".replace("{" + "favoriteId" + "}", "$favoriteId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Update Favorite Group
     * Update information about a specific favorite group.
     * @param favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
     * @param favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
     * @param userId Must be a valid user ID.
     * @param updateFavoriteGroupRequest  (optional)
     * @return void
     */
    open suspend fun updateFavoriteGroup(favoriteGroupType: kotlin.String, favoriteGroupName: kotlin.String, userId: kotlin.String, updateFavoriteGroupRequest: UpdateFavoriteGroupRequest? = null): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = updateFavoriteGroupRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/favorite/group/{favoriteGroupType}/{favoriteGroupName}/{userId}".replace("{" + "favoriteGroupType" + "}", "$favoriteGroupType").replace("{" + "favoriteGroupName" + "}", "$favoriteGroupName").replace("{" + "userId" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



}
