/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.github.kamo030.vrchatapi.apis

import io.github.kamo030.vrchatapi.models.Balance
import io.github.kamo030.vrchatapi.models.Error
import io.github.kamo030.vrchatapi.models.LicenseGroup
import io.github.kamo030.vrchatapi.models.ProductListing
import io.github.kamo030.vrchatapi.models.Subscription
import io.github.kamo030.vrchatapi.models.TiliaStatus
import io.github.kamo030.vrchatapi.models.TiliaTOS
import io.github.kamo030.vrchatapi.models.TokenBundle
import io.github.kamo030.vrchatapi.models.Transaction
import io.github.kamo030.vrchatapi.models.UserSubscription

import io.github.kamo030.vrchatapi.infrastructure.*
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

open class EconomyApi(
    baseUrl: String = ApiClient.BASE_URL,
    httpClientEngine: HttpClientEngine? = null,
    httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
    jsonSerializer: Json = ApiClient.JSON_DEFAULT
) : ApiClient(baseUrl, httpClientEngine, httpClientConfig, jsonSerializer) {

    /**
     * Get Balance
     * Gets the balance of a user
     * @param userId Must be a valid user ID.
     * @return Balance
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getBalance(userId: kotlin.String): HttpResponse<Balance> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/user/{userId}/balance".replace("{" + "userId" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get Current Subscriptions
     * Get a list of all current user subscriptions.
     * @return kotlin.collections.List<UserSubscription>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getCurrentSubscriptions(): HttpResponse<kotlin.collections.List<UserSubscription>> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/auth/user/subscription",
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetCurrentSubscriptionsResponse>().map { value }
    }

    @Serializable(GetCurrentSubscriptionsResponse.Companion::class)
    private class GetCurrentSubscriptionsResponse(val value: List<UserSubscription>) {
        @Serializer(GetCurrentSubscriptionsResponse::class)
        companion object : KSerializer<GetCurrentSubscriptionsResponse> {
            private val serializer: KSerializer<List<UserSubscription>> = serializer<List<UserSubscription>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: GetCurrentSubscriptionsResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = GetCurrentSubscriptionsResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Get License Group
     * Get a single License Group by given ID.
     * @param licenseGroupId Must be a valid license group ID.
     * @return LicenseGroup
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getLicenseGroup(licenseGroupId: kotlin.String): HttpResponse<LicenseGroup> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/licenseGroups/{licenseGroupId}".replace("{" + "licenseGroupId" + "}", "$licenseGroupId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get Product Listing
     * Gets a product listing
     * @param productId Must be a valid product ID.
     * @param hydrate Populates some fields and changes types of others for certain objects. (optional)
     * @return ProductListing
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getProductListing(productId: kotlin.String, hydrate: kotlin.Boolean? = null): HttpResponse<ProductListing> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        hydrate?.apply { localVariableQuery["hydrate"] = listOf("$hydrate") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/listing/{productId}".replace("{" + "productId" + "}", "$productId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get User Product Listings
     * Gets the product listings of a given user
     * @param userId Must be a valid user ID.
     * @param n The number of objects to return. (optional, default to 60)
     * @param offset A zero-based offset from the default object sorting from where search results start. (optional)
     * @param hydrate Populates some fields and changes types of others for certain objects. (optional)
     * @param groupId Must be a valid group ID. (optional)
     * @param active Filter for users&#39; listings. (optional)
     * @return kotlin.collections.List<ProductListing>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getProductListings(userId: kotlin.String, n: kotlin.Int? = 60, offset: kotlin.Int? = null, hydrate: kotlin.Boolean? = null, groupId: kotlin.String? = null, active: kotlin.Boolean? = null): HttpResponse<kotlin.collections.List<ProductListing>> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        n?.apply { localVariableQuery["n"] = listOf("$n") }
        offset?.apply { localVariableQuery["offset"] = listOf("$offset") }
        hydrate?.apply { localVariableQuery["hydrate"] = listOf("$hydrate") }
        groupId?.apply { localVariableQuery["groupId"] = listOf("$groupId") }
        active?.apply { localVariableQuery["active"] = listOf("$active") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/user/{userId}/listings".replace("{" + "userId" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetProductListingsResponse>().map { value }
    }

    @Serializable(GetProductListingsResponse.Companion::class)
    private class GetProductListingsResponse(val value: List<ProductListing>) {
        @Serializer(GetProductListingsResponse::class)
        companion object : KSerializer<GetProductListingsResponse> {
            private val serializer: KSerializer<List<ProductListing>> = serializer<List<ProductListing>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: GetProductListingsResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = GetProductListingsResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Get Steam Transaction
     * Get a single Steam transactions by ID. This returns the exact same information as &#x60;getSteamTransactions&#x60;, so no point in using this endpoint.
     * @param transactionId Must be a valid transaction ID.
     * @return Transaction
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getSteamTransaction(transactionId: kotlin.String): HttpResponse<Transaction> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/Steam/transactions/{transactionId}".replace("{" + "transactionId" + "}", "$transactionId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List Steam Transactions
     * Get all own Steam transactions.
     * @return kotlin.collections.List<Transaction>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getSteamTransactions(): HttpResponse<kotlin.collections.List<Transaction>> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/Steam/transactions",
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetSteamTransactionsResponse>().map { value }
    }

    @Serializable(GetSteamTransactionsResponse.Companion::class)
    private class GetSteamTransactionsResponse(val value: List<Transaction>) {
        @Serializer(GetSteamTransactionsResponse::class)
        companion object : KSerializer<GetSteamTransactionsResponse> {
            private val serializer: KSerializer<List<Transaction>> = serializer<List<Transaction>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: GetSteamTransactionsResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = GetSteamTransactionsResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * List Subscriptions
     * List all existing Subscriptions. For example, \&quot;vrchatplus-monthly\&quot; and \&quot;vrchatplus-yearly\&quot;.
     * @return kotlin.collections.List<Subscription>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getSubscriptions(): HttpResponse<kotlin.collections.List<Subscription>> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/subscriptions",
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetSubscriptionsResponse>().map { value }
    }

    @Serializable(GetSubscriptionsResponse.Companion::class)
    private class GetSubscriptionsResponse(val value: List<Subscription>) {
        @Serializer(GetSubscriptionsResponse::class)
        companion object : KSerializer<GetSubscriptionsResponse> {
            private val serializer: KSerializer<List<Subscription>> = serializer<List<Subscription>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: GetSubscriptionsResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = GetSubscriptionsResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Get Tilia Status
     * Gets the status of Tilia integration
     * @return TiliaStatus
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getTiliaStatus(): HttpResponse<TiliaStatus> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/tilia/status",
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get Tilia TOS Agreement Status
     * Gets the status of the agreement of a user to the Tilia TOS
     * @param userId Must be a valid user ID.
     * @return TiliaTOS
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getTiliaTos(userId: kotlin.String): HttpResponse<TiliaTOS> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/user/{userId}/tilia/tos".replace("{" + "userId" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List Token Bundles
     * Gets the list of token bundles
     * @return kotlin.collections.List<TokenBundle>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getTokenBundles(): HttpResponse<kotlin.collections.List<TokenBundle>> {

        val localVariableAuthNames = listOf<String>("authCookie")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/tokenBundles",
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetTokenBundlesResponse>().map { value }
    }

    @Serializable(GetTokenBundlesResponse.Companion::class)
    private class GetTokenBundlesResponse(val value: List<TokenBundle>) {
        @Serializer(GetTokenBundlesResponse::class)
        companion object : KSerializer<GetTokenBundlesResponse> {
            private val serializer: KSerializer<List<TokenBundle>> = serializer<List<TokenBundle>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: GetTokenBundlesResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = GetTokenBundlesResponse(serializer.deserialize(decoder))
        }
    }

}
